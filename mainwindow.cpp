#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow){
    ui->setupUi(this);

    // Initializing and enabling NDI tracker
    if(!connectNDI())
        cout << "Error connecting to NDI system" << endl;
    else cout << "NDI Aurora connection successful" << endl;

    // Timer for updating all data
    timer = new QTimer(this);
    timer->setInterval(UPDATE_PERIOD);
    connect(timer, SIGNAL(timeout()), this, SLOT(updateData()));
    connect(ui->recordButton, SIGNAL(clicked()), this, SLOT(onRecordClicked()));

    // Setup for pressure Sensor
    pressureSensor = new ColonoscopeSensor(FTDI_SERIALS, this);
    pressureSensor->enable(true);
    for(int i=0; i<CS_NUM_ELEMENTS; i++) {
        ui->tableRaw->setItem(i,0,new QTableWidgetItem("-"));
        ui->tableRaw->item(i,0)->setTextAlignment(Qt::AlignHCenter | Qt::AlignVCenter);
        ui->tableRaw->item(i,0)->setBackground(QBrush(QColor(255,255,255)));
        ui->tableRaw->item(i,0)->setForeground(QBrush(Qt::black));
        pressureBars[i] = new QProgressBar(ui->framePressure);
        pressureBars[i]->setObjectName(QString::fromUtf8("pressureBar")+QString::number(i));
        pressureBars[i]->setGeometry(QRect(0, i*15, 250, 16));
        pressureBars[i]->setMinimum(0);
        pressureBars[i]->setMaximum(1000);
        pressureBars[i]->setValue(0);
        pressureBars[i]->setTextVisible(false);
    }

    // Setup for QCustomPlot

    // Plot of scope curve generated by spline from the obtained EM tracker values
    curveScope = new QCPCurve (ui->customPlot->xAxis, ui->customPlot->yAxis);
    curveScope->setPen(QPen(QColor(20, 60, 255), 9));

    // Plot of EM tracker points on the customPlot
    EMtrackerPoints = new QCPGraph (ui->customPlot->xAxis, ui->customPlot->yAxis);
    EMtrackerPoints->setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, QColor(255, 255, 0), QColor(255, 255, 0), 15));
    EMtrackerPoints->setLineStyle(QCPGraph::lsNone);

    for (int i = 0; i < 8; i++)
    {
        QCPItemText *textLabel = new QCPItemText(ui->customPlot);
        textLabel->setPositionAlignment(Qt::AlignVCenter|Qt::AlignHCenter);
        textLabel->position->setType(QCPItemPosition::ptPlotCoords);
        textLabel->position->setCoords(999,999);
        textLabel->setColor(QColor(255, 0, 0));
        textLabel->setText(QString::number(i+1));
        textLabel->setVisible(true);
        EMtextLabels.push_back(textLabel);
    }

    ui->customPlot->xAxis->setRange(-300, 300);
    ui->customPlot->yAxis->setRange(-400, 400);
    ui->customPlot->axisRect()->setAutoMargins(QCP::msNone);
    ui->customPlot->xAxis->setTicks(false);
    ui->customPlot->yAxis->setTicks(false);

    // Opening the webcam and setting the required resolution
    capWebCam.open(2);
    if(!capWebCam.isOpened())
       cout << "Error opening webcam" << endl;
    else
    {
        capWebCam.set(CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT);
        capWebCam.set(CAP_PROP_FRAME_WIDTH, FRAME_WIDTH);
        cout << "Received webcam feed" << endl;
    }

    // Opening the colonscope camera and setting the required resolution
    capColCam.open(0);
    if(!capColCam.isOpened())
       cout << "Error opening colonoscope camera" << endl;
    else
    {
        capColCam.set(CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT_COL);
        capColCam.set(CAP_PROP_FRAME_WIDTH, FRAME_WIDTH_COL);
        cout << "Received colonoscope camera feed" << endl;
    }

    // Load camera Intrinsics matrix
    if (loadCameraIntrinsics(cameraIntrinsicsFile, cameraIntrinsicMatrix, distanceCoefficients))
        cout << "Camera Intrinsic parameters loaded successfully" << endl;
    else cout << "Camera Intrinsic parameters reading error" << endl;

    // Start the timer for GUI
    timer->start();
}

MainWindow::~MainWindow(){
    timer->stop();
    capWebCam.release();
    capColCam.release();
    videoWebCam.release();
    videoColCam.release();
    capi.stopTracking();
    pressureSensor->enable(false);
    delete pressureSensor;
    delete timer;
    delete ui;
}

void MainWindow::onRecordClicked(){
    record = !record;
    if (record){
        this->ui->recordButton->setText("Stop Recording");
        this->ui->arucoCheckBox->setEnabled(false);
        this->ui->pressureCheckBox->setEnabled(false);
        this->ui->colCamCheckBox->setEnabled(false);
        this->ui->webCamCheckBox->setEnabled(false);

        EMFileName = "Data/EMTracking%1.csv";
        int fileNumber = 0;
        while(QFile(EMFileName.arg(fileNumber, 3, 10, QChar('0'))).exists()) fileNumber++;
        EMFileName = EMFileName.arg(fileNumber, 3, 10, QChar('0'));

        webCamFileName = EMFileName;
        webCamFileName.replace("EMTracking", "WebCamVideo");
        webCamFileName.replace("csv", "avi");
        videoWebCam = VideoWriter(webCamFileName.toStdString(), VideoWriter::fourcc('M', 'J', 'P', 'G'), 20, Size(FRAME_HEIGHT, FRAME_WIDTH), true);

        colCamFileName = EMFileName;
        colCamFileName.replace("EMTracking", "ColCamVideo");
        colCamFileName.replace("csv", "avi");
        videoColCam = VideoWriter(colCamFileName.toStdString(), VideoWriter::fourcc('M', 'J', 'P', 'G'), 20, Size(FRAME_WIDTH_COL, FRAME_HEIGHT_COL), true);

        pressureFileName = EMFileName;
        pressureFileName.replace("EMTracking", "Pressure");

        arucoFileName = EMFileName;
        arucoFileName.replace("EMTracking", "ColonTracking");
    }
    else {
        videoWebCam.release();
        videoColCam.release();
        this->ui->recordButton->setText("Start Recording");
        this->ui->arucoCheckBox->setEnabled(true);
        this->ui->pressureCheckBox->setEnabled(true);
        this->ui->colCamCheckBox->setEnabled(true);
        this->ui->webCamCheckBox->setEnabled(true);
    }
}

void MainWindow::updateData()
{
    // Update camera feeds

    capColCam >> frameColCam;
    if(!frameColCam.empty())
    {
        cvtColor(frameColCam, frameColCam, COLOR_BGR2RGB);
        QImage currentFrameCol= QImage((uchar*) frameColCam.data, frameColCam.cols, frameColCam.rows, frameColCam.step, QImage::Format_RGB888);
        ui->colCamWidget->setPixmap(QPixmap::fromImage(currentFrameCol).scaled(ui->colCamWidget->width(), ui->colCamWidget->height(), Qt::KeepAspectRatio));
        ui->colCamWidget->setAlignment(Qt::AlignCenter);
        ui->colCamWidget->show();
    }
    capWebCam >> frameWebCam;
    if (!frameWebCam.empty())
    {
        rotate(frameWebCam, frameWebCam, cv::ROTATE_90_CLOCKWISE);
        cvtColor(frameWebCam, frameWebCam, COLOR_BGR2RGB);

        // Draw the axis of the markers; XYZ axes are BGR
        vector<vector<Point2f>> markerCorners, rejectedCandidates;
        aruco::detectMarkers(frameWebCam, markerDictionary, markerCorners, markerIds, parameters, rejectedCandidates);
        aruco::estimatePoseSingleMarkers(markerCorners, arucoSquareDim, cameraIntrinsicMatrix, distanceCoefficients, rotVec, transVec);
        Mat outputFrame = frameWebCam.clone();
        for(size_t i = 0; i<markerIds.size(); i++){
            aruco::drawAxis(outputFrame, cameraIntrinsicMatrix, distanceCoefficients, rotVec[i], transVec[i], 0.03f);
            //cout << markerIds[i] << ": " << transVec[i] << endl;
        }
        // Displaying original frame
        QImage currentFrame= QImage((uchar*) outputFrame.data, outputFrame.cols, outputFrame.rows, outputFrame.step, QImage::Format_RGB888);
        ui->webCamWidget->setPixmap(QPixmap::fromImage(currentFrame).scaled(ui->webCamWidget->width(), ui->webCamWidget->height(), Qt::KeepAspectRatio));
        ui->webCamWidget->setAlignment(Qt::AlignCenter);
        ui->webCamWidget->show();
    }

    // Update pressure sensor data

    if(pressureSensor->getStatus() != ColonoscopeSensor::CS_ACTIVE)
    {
        for(int i=0; i<CS_NUM_ELEMENTS; i++){
            ui->tableRaw->item(i,0)->setText("-");
            pressureBars[i]->setValue(0);
        }
    }
    else
    {
        pressureSensor->getValues(currentReadings);
        for(int i=0; i<CS_NUM_ELEMENTS; i++) {
            ui->tableRaw->item(i, 0)->setText(QString::number(currentReadings[i]));
            int percentPressure = (int)((CS_MAX_VALUE-currentReadings[i]) * 1000.0 / CS_MAX_VALUE);
            if (percentPressure > 1000) percentPressure = 1000;
            QColor col1 = gradient(percentPressure,0,1000);
            QString st = "QProgressBar::chunk { background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 %1, stop:1 %2); margin: 1px 1px 1px 1px; }";
            QColor col2(col1);
            col2.setHsl(col2.hslHue(),col2.hslSaturation(),qMin(col2.lightness()+80, 255));
            pressureBars[i]->setStyleSheet(st.arg(col2.name(),col1.name()));
            pressureBars[i]->setValue(percentPressure);
        }
    }

    // Update EM Tracker data

    QVector<QVector<double>> scopePosition(4);
    vector<ToolData> newToolData = capi.getTrackingDataBX(TrackingReplyOption::TransformData | TrackingReplyOption::AllTransforms);

    // Update enabledTools array with new data
    for (uint t = 0; t < enabledTools.size(); t++)
    {
        for (uint j = 0; j < newToolData.size(); j++)
        {
            if (enabledTools[t].transform.toolHandle == newToolData[j].transform.toolHandle)
            {
                // Copy the new tool data
                newToolData[j].toolInfo = enabledTools[t].toolInfo; // keep the serial number
                enabledTools[t] = newToolData[j]; // use the new data
            }
        }
        if (!enabledTools[t].transform.isMissing()){
            // Box field generator
            // scopePosition[0].push_back(-enabledTools[t].transform.ty);
            // scopePosition[1].push_back(enabledTools[t].transform.tz);
            // scopePosition[2].push_back(-enabledTools[t].transform.tx);
            // scopePosition[3].push_back(1.0);
            // Planar field generator
            scopePosition[0].push_back(-enabledTools[t].transform.tx);
            scopePosition[1].push_back(enabledTools[t].transform.ty);
            scopePosition[2].push_back(-enabledTools[t].transform.tz);
            scopePosition[3].push_back(1.0);
            EMtextLabels[t]->position->setCoords(scopePosition[0].back(), scopePosition[1].back());
        }
        else
            EMtextLabels[t]->position->setCoords(999, 999);
    }
    makeSplineQCP(scopePosition);
    scopePosition.clear();

    if (record){
        qint64 timestamp = QDateTime::currentMSecsSinceEpoch();

        if(ui->webCamCheckBox->isChecked()){
            cvtColor(frameWebCam, frameWebCam, COLOR_BGR2RGB);
            videoWebCam.write(frameWebCam);
        }
        if(ui->colCamCheckBox->isChecked()){
            cvtColor(frameColCam, frameColCam, COLOR_BGR2RGB);
            videoColCam.write(frameColCam);
        }
        if(ui->emCheckBox->isChecked()){
            ofstream csvFile(EMFileName.toStdString().c_str(), ofstream::app);
            stringstream stream;
            stream << timestamp << ",";
            for (uint i = 0; i<enabledTools.size(); i++){
                stream << "Port:" << enabledTools[i].transform.toolHandle << ",";
                if (enabledTools[i].transform.isMissing())
                    stream << "Missing,,,,";
                else
                    stream << TransformStatus::toString(enabledTools[i].transform.getErrorCode()) << ","
                           << -enabledTools[i].transform.tx << "," << enabledTools[i].transform.ty << "," << -enabledTools[i].transform.tz << ",";
            }
            csvFile << stream.str();
            csvFile << endl;
            csvFile.close();
        }
        if(ui->pressureCheckBox->isChecked()){
            ofstream csvFile(pressureFileName.toStdString().c_str(), ofstream::app);
            stringstream stream;
            stream << timestamp << ",";
            for (int i = 0; i<CS_NUM_ELEMENTS; i++)
                stream << currentReadings[i] << ",";
            csvFile << stream.str();
            csvFile << endl;
            csvFile.close();
        }
        if(ui->arucoCheckBox->isChecked()){
            ofstream csvFile(arucoFileName.toStdString().c_str(), ofstream::app);
            stringstream stream;
            stream << timestamp << ",";
            for (size_t i = 0; i<markerIds.size(); i++){
                stream << markerIds[i] << ",";
                stream << transVec[i].val[0] << "," << transVec[i].val[1] << "," << transVec[i].val[2] << ",";
                stream << rotVec[i].val[0] << "," << rotVec[i].val[1] << "," << rotVec[i].val[2] << "," ;
            }
            csvFile << stream.str();
            csvFile << endl;
            csvFile.close();
        }
    }
}

// Prints a debug message if a method call failed.
void MainWindow::onErrorPrintDebugMessage(string methodName, int errorCode)
{
    if (errorCode < 0)
        cout << methodName << " failed: " << capi.errorToString(errorCode) << endl;
}

bool MainWindow::connectNDI(){

    string hostname = "/dev/ttyUSB1";
    cout << "Trying to connect..." << endl;

    // Attempt to connect to the device
    if (capi.connect(hostname) != 0)
    {
        // Print the error and exit if we can't connect to a device
        cout << "Connection Failed!" << endl;
        return false;
    }
    cout << "Connected!" << endl;

    // Initialize the system. This clears all previously loaded tools, unsaved settings etc...
    onErrorPrintDebugMessage("capi.initialize()", capi.initialize());
    QThread::sleep(1);

    // Initialize and enable tools
    vector<PortHandleInfo> portHandles = capi.portHandleSearchRequest(PortHandleSearchRequestOption::NotInit);
    for (uint i = 0; i < portHandles.size(); i++)
    {
        cout << "Configuring an Active Wired Tool - Loading .rom File..." << endl;
        capi.loadSromToPort("srom-2x5dof.rom", portHandles[i].getPortHandle());
        onErrorPrintDebugMessage("capi.portHandleInitialize()", capi.portHandleInitialize(portHandles[i].getPortHandle()));
    }
    portHandles = capi.portHandleSearchRequest(PortHandleSearchRequestOption::NotEnabled);
    for (uint i = 0; i < portHandles.size(); i++)
        onErrorPrintDebugMessage("capi.portHandleEnable()", capi.portHandleEnable(portHandles[i].getPortHandle()));

    // Print all enabled tools
    portHandles = capi.portHandleSearchRequest(PortHandleSearchRequestOption::Enabled);
    if (portHandles.size() < 1)
    {
        cout << "Cannot read data if no tools are enabled!" << endl;
        return false;
    }
    else{
        for (uint i = 0; i < portHandles.size(); i++)
            cout << portHandles[i].toString() << endl;
    }

    // Lookup and store the serial number for each enabled tool
    for (size_t i = 0; i < portHandles.size(); i++)
    {
        enabledTools.push_back(ToolData());
        enabledTools.back().transform.toolHandle = (uint16_t) capi.stringToInt(portHandles[i].getPortHandle());
        PortHandleInfo info = capi.portHandleInfo(portHandles[i].getPortHandle());
        enabledTools.back().toolInfo = info.getToolId();
        enabledTools.back().toolInfo.append(" s/n:").append(info.getSerialNumber());
    }

    // Start tracking
    onErrorPrintDebugMessage("capi.startTracking()", capi.startTracking());
    return true;
}

void MainWindow::makeSplineQCP(QVector<QVector<double>> scopePosition){
    if (scopePosition.empty() || scopePosition[0].size()<2)
        return;

    int numSegments = scopePosition[0].size() - 1;    // Number of segments in the curve
    MatrixXd M = MatrixXd::Constant(3*numSegments, 3*numSegments, 0.0); // Initialize a matrix to solve for unknowns of cubic spline

    // Making a matrix which looks like following for 3 segments (size (3*segments, 3*segments))
    //       [1  1  1  0  0  0  0  0  0
    //        0  0  0  1  1  1  0  0  0
    //        0  0  0  0  0  0  1  1  1
    //        1  2  3 -1  0  0  0  0  0
    //        0  0  0  1  2  3 -1  0  0
    //        0  1  3  0 -1  0  0  0  0
    //        0  0  0  0  1  3  0 -1  0
    //        0  1  0  0  0  0  0  0  0
    //        0  0  0  0  0  0  0  1  3]

    for (int i = 0; i < numSegments; i++) {
         M(i, 3*i) = 1;
         M(i, 3*i+1) = 1;
         M(i, 3*i+2) = 1;
    }
    // Equations for matching the slope (first derivative)...
    // And curvature (second derivative) at every knot between two segments
    for (int i = 0; i < (numSegments - 1); i++) {
         M(i + numSegments, 3*i) = 1;
         M(i + numSegments, 3*i+1) = 2;
         M(i + numSegments, 3*i+2) = 3;
         M(i + numSegments, 3*i+3) = -1;
         M(i + numSegments*2 - 1, 3*i+1) = 1;
         M(i + numSegments*2 - 1, 3*i+2) = 3;
         M(i + numSegments*2 - 1, 3*i+4) = -1;
    }
    // Boundary conditions that make curvature (second derivative) = 0 at extreme knots
    M(numSegments*3 - 2, 1) = 1;
    M(numSegments*3 - 1, 3*numSegments-2) = 1;
    M(numSegments*3 - 1, 3*numSegments-1) = 3;

    MatrixXd Minv = M.inverse();

    // Create right hand side of the equation
    // for 3 segments right hand vector is of size (3*segments) and looks like
    //   [(x1 - x0), (x2 - x1), (x3 - x2), 0, 0, 0, 0, 0, 0]
    //   3 unknowns for each segment hence (3*segments) rows and 3 columns for X, Y, and Z
    MatrixXd B = MatrixXd::Constant(3*numSegments, 3, 0.0);
    for (int i = 0; i < 3*numSegments; i++)
    {
        if (i<numSegments){
            B(i, 0) = scopePosition[0][i + 1] - scopePosition[0][i];
            B(i, 1) = scopePosition[1][i + 1] - scopePosition[1][i];
            B(i, 2) = scopePosition[2][i + 1] - scopePosition[2][i];
        }
        else {
            B(i, 0) = 0; B(i, 1) = 0; B(i, 2) = 0;
        }
    }

    // Calculate the unknowns of the equations
    MatrixXd A = Minv * B;

    // Calculate the interpolated values of x, y, and z
    int k = 0;
    float ss = 0.0166; // stepsize
    int steps = 1/ss;
    QVector<QVector<double>> XYZnew(4, QVector<double>(numSegments * steps));

    for (int i = 0; i < numSegments; i++) {
        float t = 0.0;
        for (int j = 0; j < steps; j++) {
             XYZnew[0][k] = scopePosition[0][i] + A(3*i, 0)*t + A(3*i + 1, 0)*t*t + A(3*i + 2, 0)*t*t*t;
             XYZnew[1][k] = scopePosition[1][i] + A(3*i, 1)*t + A(3*i + 1, 1)*t*t + A(3*i + 2, 1)*t*t*t;
             XYZnew[2][k] = scopePosition[2][i] + A(3*i, 2)*t + A(3*i + 1, 2)*t*t + A(3*i + 2, 2)*t*t*t;
             XYZnew[3][k] = 1;
             k++;
             t = t + ss;
        }
    }

    //Plot the new curves
    curveScope->setData(XYZnew[0], XYZnew[1]);
    EMtrackerPoints->setData(scopePosition[0], scopePosition[1]);
    ui->customPlot->replot();
}

bool MainWindow::loadCameraIntrinsics(string name, Mat& cameraIntrinsics, Mat& distanceCoefficients){
    ifstream inStream(name);
    if(inStream){
        uint16_t rows, columns;
        inStream >> rows;
        inStream >> columns;
        cameraIntrinsics = Mat(Size(rows, columns), CV_64F);
        for(int r = 0; r < rows; r++){
            for (int c = 0; c < columns; c++){
                double read = 0.0f;
                inStream >> read;
                cameraIntrinsics.at<double>(r, c) = read;
            }
        }

        inStream >> rows;
        inStream >> columns;
        distanceCoefficients = Mat::zeros(rows, columns, CV_64F);
        for(int r = 0; r < rows; r++){
            for (int c = 0; c < columns; c++){
                double read = 0.0f;
                inStream >> read;
                distanceCoefficients.at<double>(r, c) = read;
            }
        }
        inStream.close();
        return true;
    }
    return false;
}

QColor MainWindow::gradient(double value, double low, double high){
    double mid = (low + high)/2, lquart = (low + mid)/2, uquart = (mid + high)/2;
    QColor col(128,128,128);
    if(value < low) value = low;
    if(value > high) value = high;
    if(value < lquart)
        col.setRgb(0,(int)((value - low)*255/(lquart - low)),255);
    else if(value < mid)
        col.setRgb(0,255,(int)((value - mid)*255/(lquart - mid)));
    else if(value < uquart)
        col.setRgb((int)((value - mid)*255/(uquart - mid)),255,0);
    else
        col.setRgb(255,(int)((value - high)*255/(uquart - high)),0);
    return col;
}

